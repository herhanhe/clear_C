clear_c

## chap01:猜数游戏
	内容：* if语句的结构/效率/可读性
	      *	do语句（先循环后判断）
	      * while语句（先判断后循环）
	      * for语句（先判断后循环）
	      * break语句
	      * 相等运算符和关系运算符
	      * 逻辑运算符
	      * 增量运算符（前置/后置）
	      * sizeof运算符
	      * 表达式求值
              * 德.摩根定律
	      * 随机数的生成与种子的变更
	      * 对象宏
	      * 数组
	      * 数组的遍历
	      * 数组元素初始化
	      * 数组元素个数的设定和获取
              rand函数 srand函数 RAND_MAX
	
小结：<br/>
+ **生成随机数的准备工作（设定种子）**<br/>
生成随机数之前需要基于当前时间设定“种子”的值。<br/>
```c
	#include <time.h>
	#include <stdlib.h>
	/*...*/
	srand(time(NULL));	 /*设定随机数的种子*/
```
&emsp;&emsp;&emsp;在最初调用`rand`函数之前先调用`srand`函数（至少调用一次，调用次数不限）。<br/>
&emsp;&emsp;&emsp;如果没有做上述注备工作，那么种子的值就会默认为1，会生成相同的随机数序列。
+ **生成随机数**<br/>
一旦调用`rand`函数，就会得到一个大于等于0且小于等于`RAND_MAX`的随机数。`RAND_MAX`的值取决于编程环境，即大于等于32767。<br/>
此外，如果想把随机数定在某个特定范围内，可以像下面这样操作。<br/>
```c
	rand() % (a + 1)    /*大于等于0且小于等于a的随机数*/
	b + rand() % (a + 1)	/*大于等于b且小于等于b + a的随机数*/
```
+ **增量运算符和减量运算符**<br/>
对操作数的值进行增量运算符“++”，以及对操作数的值进行减量操作的减量运算符“--”都包括前置形式和后置形式。前置形式会在对表达式进行求值之前对操作数进行增量或减量操作，后置形式则会在对表达式进行求值之后再对操作数进行增量或减量操作。
+ **数组**<br/>
数组是一种将同一类型的元素排成一列的数据结构。声明数组时需要赋予数组元素类型和元素个数。此时元素个数必须是一个常数表达式。我们在访问各个元素时使用下标运算符“[]”,第一元素的下标是0。<br/>
数组的初始值的形式是对应各个元素把初始值按照顺序依次排列并用逗号“，”一一隔开，再用“{}”把它们括起来。
```c
	int a[] = {1,2,3};
```
+ **数组元素**<br/>
一般情况下，即使我们不进行声明，也需要知道数组的元素个数，大家可以像下面这样声明。<br/>
1、事先用对象宏定义元素个数。
```c
	#define NA 7		/*先定义数组a的元素个数*/
	int a[NA];
```
&emsp;&emsp;&emsp;2、声明数组后获取元素个数。
```c
	int a[7];
	int na = sizeof(a)/sizeof(a[0]);	/*后获取数组a的元素个数*/
```
## chap02:专注于显示
	内容：*转义字符
	      *警报符
	      *换行符和回车符
	      *退格符
	      *tab
	      *引号
	      *消除或改写显示的字符
              *暂时处理一段时间
	      *计算处理时间
	      *类型转换
	      *字符串
	      *空字符
	      *typedef声明
	      *格式化输入/输出
	      clock_t型
	      clock 函数
	      printf 函数
	      putchar 函数
	      scanf 函数
	      strlen 函数
	      CLOCKS_PER_SEC
小结：<br/>
&emsp;&emsp;&emsp;转义字符是一个通过在字符开头加上反斜杠“\”来表示单个字符的表示方法。
+ **警报符`\a`**<br/>
发出警报。在大多数环境下发出的是“蜂鸣音”。
+ **换行符`\n`**<br/>
将光标移动到下一行的开头。连续输出2次能够输出空行。
+ **退格符`\b`**<br/>
将光标往后退一格。输出“`\b` `\b`”能够消除最后一个字符。
+ **回车符`\r`**<br/>
将光标移到本行开头。要重写本行已显示的字符时，可输出回车符`\r`，然后直接输出想重写的内容。
+ **引号**<br/>
字符常量：表示单引号必须使用`\'`,表示双引号可以用`"`或`\"`。<br/>
字符串常量：表示双引号必须使用`\"`,表示单引号可以用`'`或`\'`。
+ **八进制转义字符和十六进制转义字符**<br/>
用编码表示字符（不同编码系统环境间不存在可移植性）。
+ **获取程序启动后经过的时间**<br/>
调用`clock`函数后，就能以`clock_t`型的数值形式获取程序启动后进过的时钟数。时钟的单位根据程序环境不同而有所差别，但都能通过除以`CLOCK_PER_SEC`来换算成以秒为单位的数值。<br/>
然而，这样直接进行除法运算的话会舍去小数部分，因此求实数值时，需要将时间强制转换成`double`型，再进行`(double)clock()/CLOCKS_PER_SEC`的操作。
+ **计算处理所需的时间**<br/>
准备两个`clock_t`型的变量，分别保存`clock`函数在处理前和处理后的返回值。<br/>
```c
	clock_t start,end;		/*开始时间·结束时间*/
	start = clock();
	/*---(处理)---*/
	end = clock();
```
&emsp;&emsp;&emsp;此时的（处理）所需的时间是`end`减去`start`的时钟数。<br/>
&emsp;&emsp;&emsp;把这个值除以`CLOCKS_PER_SEC`就能换算成以秒为单位的值。直接进行除法运算的话会舍去小数部分，所以想求出实数值的话，就必须将其强制转换成`double`型。
```c
	(double)(end - start)/CLOCKS_PER_SEC	/*(处理)所需的时间*/
```
&emsp;&emsp;&emsp;变量名称随意，不用`start`和`end`也行。
+ **暂停处理一段时间**<br/>
事先准备并调用下面的`sleep`函数，参数的单位是毫秒。
```c
	/*---等待x毫秒---*/
	int sleep(unsigned long x)
	{
		clock_t c1 = clock(), c2;
		do {
			if ((c2 = clock()) == (clock_t)-1)		/*错误*/
				return 0;
		} while (1000.0 * (c2 - c1)/CLOCKS_PER_SEC < x);
		return 1;
	}	
```
&emsp;&emsp;&emsp;因程序运行时间过长而导致数值无法用`clock_t`型表示，从而发生溢出时，采用上述方法可能无法得到期望的结果。<br/>
&emsp;&emsp;&emsp;这种情况下就需要放弃以毫秒为单位，而采用秒为单位来进行处理。
+ **输出时位数的调整**<br/>
使用`printf`函数显示信息时，可以通过在格式字符中设置“`*`”，并赋给“`*`”一个与其对应的参数，来指定要显示的位数。<br/>
下面是几个例子。
```c
	/*至少用i位数表示123*/
	for (i = 2; i < 5; i++)
		printf("%*d\n", i, 123);
	/*用6位数表示3.141592，小数点以后的位数用i位数表示*/
	for (i = 2; i < 5; i++)
		printf("%*.*f\n",6,i,3.141592);
	/*在A和B之间显示i个空白字符*/
	for (i = 0; i < 5; i++)
		printf("A%*sB\n",i,"");
	/*显示ABCDE的前i个字符*/
	for (i = 0; i < 5; i++)
		printf("%.*s\n",i,"ABCDE");
```

## chap03:猜拳游戏
	内容：*switch语句
	      *char型
	      *条件运算符和条件表达式
	      *特定范围内的数值的读取
	      *字符编码
	      *包含汉字的字符串
	      *宽字符
	      *通过指针来遍历字符串
	      *字符串数组（二维数组/指针数组）
	      *函数
	      *标识符的作用域
	      wchar_t型
	      isprint函数
	      CHAR_BIT
	      CHAR_MAX
	      CHAR_MIN
              SCHAR_MAX
              SCHAR_MIN
              UCHAR_MAX
小结：
+ **选择语句（if语句和switch语句）**<br/>
如果要用单一表达式的值来实现程序流程分支，多数情况下，`switch`语句要比`if`语句更加合适（更加容易把握程序的目的）。												
+ **判断显示字符**<br/>
可以通过`isprint`函数来判断字符是否为显示字符（能够显示的字符）。
+ **char型的特性**<br/>
`char`型的特性视编程环境而异。`CHAR_BIT`等对象宏用于表示`char`型的位数，由`<limits.h>`头文件来定义。
+ **字符串的遍历**<br/>
可以通过对指正`s`进行怎量操作，一直到`*s`变成0，即空字符为止，来遍历指针`s`指向的字符串。<br/>
表达式`*s`是该指针所指对象的别名（绰号）。
```c
	while (*s) {
		/*---省略---*/
		s++;
	}
```
+ **字符串数组**<br/>
字符串的集合可以用二维数组或指针数组来表示。字符串的长度不同时（特别是包含全角字符时），多数情况下更适合选用后者。
```c
	/*---二维数组---*/
	char a[][6] = {
		"Super","X","TRY"
	};
```
![3.1](https://img.vim-cn.com/e0/d80ac7b42fa24a39aaae2f1981ffd785ef2e4c.png)<br/>
```c
	/*---指针数组---*/
	char *p[] = {
		"Super","X","TRY"
	};
```
![3.2](https://ae01.alicdn.com/kf/H4766c41e02454de2b62328a585cbc48bo.png)<br/>
&emsp;&emsp;&emsp;二维数组是一个行`x`列的表。<br/>
&emsp;&emsp;&emsp;使用指针数组时，需要注备用于储存各个字符串的空间，以及用于存储指针数组的空间。

## chap04:珠玑妙算
	内容：*生成不重复的随机数
	      *检查数组内的重复元素
	      *将数值作为字符串来读取
	      *判断字符类型
	      *数字字符的性质
	      *数字字符的整数值的相互转换
	      *作为函数参数的指针
	      atof函数
	      atoi函数
	      atol函数
	      isalnum函数
	      isalpha函数
	      iscntrl函数
	      isdigit函数
	      isgraph函数
	      islower函数
	      isprint函数
	      ispunct函数
	      isspace函数
	      isupper函数
	      isxdigit函数

小结：
+ **数字字符的字符编码**<br/>
数字字符'0','1',...,'9'的编码虽然取决于字符编码体系，但其编码在所有字符编码体系中都是以1为单位依次递增的。
+ **数字字符和数值间的转换**<br/>
在整数值0,1,...,9上加上'0',可以得到对应的数字字符'0','1',...,'9'。反过来，从数字字符'0','1',...,'9'中减去'0'，则可以得到对应的整数值。<br/>
![4.1](https://img.vim-cn.com/53/fc07d34ddc729ee334f3d2b15500d5c4d63dc9.png)
+ **数字字符的判断**<br/>
可以通过`isdighit(c)`来判断字符'c'是否为数字字符。
由于是连续的10个数字字符的字符编码，因此也可通过`c >= '0' && c <= '9'`来判断。
+ **字符类别的判断**<br/>
用于判断字符类别的库函数包括以下几种。<br/>
iscntrl:控制字符&emsp;isspace:空白字符&emsp;isprint:显示字符<br/>
isdigit:十进制数字&emsp;isxdigit:十六进制数字&emsp;isgraph:除空白字符以外的显示字符<br/>
isupper:大写英文字符&emsp;islower:小写英文字符&emsp;isalpha:英文字符<br/>
isalnum:英文字符或数字字符&emsp;ispunct:除空白字符、数字字符、英文字符以外的显示字符。<br/>
无论哪个函数，只要判断成立就返回除0以外的值，不成立则返回0.
+ **把字符串转换成数值**
要把字符串转换成数值，可以根据字符串类型分别使用函数`atof、atol、atof`

## chap05:记忆力训练
	内容：*整数型的表示范围
		  *如何处理不依赖编程环境的英文字符
		  *通过符号字符显示条形图（横向和纵向）
		  *比较字符串
		  *相邻的字符串常量
		  *数组元素的循环利用
		  *存储空间的动态分配与释放
		  size_t型
		  calloc函数
		  free函数
		  malloc函数
		  strcmp函数
		  strncmp函数
小结：
+ **整数型的表示范围**<br/>
整数型表示的数值范围有限。无论哪种编程环境，超过`32767`的值都不能用`int`型和`rand`函数来处理。<br/>
尽管`rand`函数的返回值类型是`int`型,但随机数的最大值`RAND_MAX`不一定等于`int`型能够表示的最大值。<br/>
一个表示大数值的方法就是将其数字字符串来处理。<br/>
+ **字符串的比较**<br/>
判断两个字符串的大小关系时，要使用`strcmp`函数。只判断字符串前面的字符的大小关系时，使用`strncmp`函数。<br/>
这两个函数的相同点是：若第1参数的字符串小于第2参数的字符串，就返回负值；若第1参数的字符串大于第2参数的字符串，就返回正值；若两个参数的字符串相等，就返回0。
+ **英文字母的字符编码**<br/>
在`EBCDIC`编码中，英文字母`'A'、'B'、...、'Z'`的编码并不是以1为单位逐渐递增的，因此下面这种处理英文字母的各个字符的方法不具有可移植性。<br/>
&emsp;在`'A'`上加上`0~25`,得到`'A' ~ 'Z' =` 用于`'A' + n`求从前往后数的第`n`个字符。<br/>
&emsp;在`'a'`上加上`0~25`,得到`'a' ~ 'z' =`用于`'a' + n`求从前往后数的第`n`个字符。<br/>
为了在处理英文字母时不受编程环境的影响，我们可以定义一个像下面这样的数组。<br/>
&emsp;大写字母`const char upr[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"`;<br/>
&emsp;小写字母`const char lwr[] = "abcdefghijklunopqrstuvwxyz"`;<br/>
使用这些数组就能以`upr[i]`或`lwr[i]`的形式访问从前往后数的第`n`个字符。
+ 为了把数组当作能够按照时间先后顺序丢弃旧值的有界缓冲区来使用，可以将其视为一个循环结构来访问。
+ **存储空间的动态分配与释放**<br/>
我们可以在程序运行时的任意时刻分配所需大小的存储空间，释放或丢弃不需要的空间。<br/>
用于分配存储空间的两个函数是`calloc`函数和`malloc`函数。这两个函数能从专门留出的空闲空间中分配存储空间，这些空闲空间一般称为堆。`calloc`函数会把已分配的空间的所有位都初始化为0，而`malloc`函数则不会进行初始化。<br/>
在程序运行时通过这些函数分配了存储空间的对象的生存期（寿命）叫作动态存储期。<br/>
用于释放不需要的空间的是`free`函数。<br/>
`calloc、malloc、free`这3个函数接收和返回的`void *`型的指针（指向`void`的指针）这个类型的指针是一种能够跟其他类型的指针相互赋值的万能指针类型。<br/>
分配存储空间时，不会指定要"为整数分配存储空间。"或"为数组分配存储空间。"(没有必要指定)。这是因为`calloc`函数和`malloc`函数分配的只是存储空间的"块"。<br/>
假设我们把已分配的空间赋给了`Type *`型的指针`p`,则现在可以灵活进行如下应用。<br/>
&emsp;通过表达式`*p`将已分配的空间当成单独的`Type`型对象来访问。<br/>
&emsp;通过表达式`p[i]`将已分配的空间当成由`Type`型元素构成的数组来访问。
![5.1](https://img.vim-cn.com/4e/84d5f89aad6fa3b055717778eb7195df0d4af9.png
)
## chap06:日历
	内容：*日历时间和分解时间
		  *获取当前日期和时间
		  *通过当前时间设定随机数种子
		  *计算处理时间
		  *星期的求法与日历
		  *空指针和空指针常量
		  *拼写相同的字符串常量
		  *命令行参数
		  struct tm 型
		  time_t 型
		  asctime 函数
		  ctime 函数
		  difftime 函数
		  gmtime 函数
		  localtime 函数
		  mktime 函数
		  sprintf 函数
		  strcat 函数
		  strcpy 函数
		  time 函数
          tolower 函数
		  toupper 函数
		  NULL
小结：
我们能够借助日历时间和分解时间来表示日期和时间。
+ **日历时间（time_t型）**<br/>
日历时间被定义为等同于算术型。大多数编程环境都将自1970年1月1日0时0分0秒后经过的秒数作为日历时间的值。<br/>
可以通过`time`函数以日历时间的形式获取当前（程序运行时）的时间。<br/>
+ **分解时间（tm结构体）**<br/>
分解时间被定义为报年月日时分秒等作为各个成员的结构体。<br/>
下图揭示了如何获取当前时间并将其转换成日历时间/分解时间/字符串。<br/>
`asctime`函数和`ctime`函数生成的字符串的末尾附有换行符。如果不想要换行符，可以使用`List6-4`的函数`asctime2`和`List6-6`的函数`ctime2`。<br/>
![6.1](https://ae01.alicdn.com/kf/H871328a13cd84013b6a4f943b72e2d71K.png)
+ **日历时间的差**<br/>
可以借助`difftime`函数以`double`型的实数值的形式求出两个日历时间的差。<br/>
+ **暂停处理一段时间**<br/>
可以选用下列函数来把处理暂停一段时间。<br/>
sleep函数：适用于暂停时间短、精度高的情况。<br/>
ssleep函数：适用于暂停时间长、不要求精度的情况。
+ **日期和时间的库的限制**<br/>
c语言提供的关于日期和时间的标准库只保证能正确处理1970年1月1日及其以后的日期和时间。
+ **把分解时间转换成日历时间**<br/>
可以通过`mktime`函数把分解时间转换成日历时间。此时，函数会自动计算并设定分解时间的星期（成员`tm_wday`）和一年中经过的天数（成员`tm_yday`）。这样一来，即时不需要把分解时间转换成日历时间，也能通过只调用`mktime`函数求出该日期是星期几（星期日是0，星期一是1，星期二是2.....星期六是6）。
+ **蔡勒公式**<br/>
利用蔡勒公式能求出1582年10月15日及其以后的日期所对应的星期。下述表达式用于求`year`年`mouth`月`day`日是星期几。<br/>
`(year + year/4 - year/100 + year/400 + (13*month + 8)/5 + day) % 7`
+ **字符串的复制**<br/>
用`strcpy(s1,s2)`可以把字符串s2复制到字符串s1。<br/>
+ **字符串的连接**<br/>
用`strcat(s1,s2)`可以把字符串s2连接到字符串s1的后面。<br/>
+ **清空字符串**<br/>
把空字符赋给字符串`str`的开头字符，可清空字符串`str`。<br/>
`str[0] = '\0';`<br/>
也可以调用`strcpy(str,"")`来实现，但不建议使用。
+ **生成带有格式的字符串**<br/>
利用sprintf函数可以生成带有格式的字符串。<br/>
该函数并不像`printf`函数那样会把参数输出到标准输出流(控制台画面)，而是会把参数输出到第1参数指定的`char`型数组。
+ **命令行参数的接收**<br/>
为了获取命令行给出的字符串，`main`函数以程序名和程序形成参数的形式接受下列两个参数。<br/>
argc:程序名和程序形式参数的总个数。<br/>
argv:指向“指向程序名和程序形式参数的”指针数组的开头元素的指针。
```c
	int main (int argc,char *argv[]){
		/*...*/
	}
```
![6.2](https://ae01.alicdn.com/kf/He9aa25e3a3d4452fb873094205e9b60e8.png)

## chap07:右脑训练
	内容：*数组的复制
		  *数组元素的重新排列
		  *赋值运算符和逗号运算符
		  *两个值的交换
		  *函数宏
		  *空语句
		  *包含头文件保护的头文件的设计
		  *可变参数的访问
		  *多维数组的初始值
		  *实时的键盘输入
		  *Curses库
		  va_list型
		  va_arg宏
		  va_end宏
		  va_start宏
		  vprintf函数
		  vsprintf函数
          getch函数 ×C语言的非标准库
		  putch函数 ×C语言的非标准库 
小结：
+ **复制数组**<br/>
即使元素类型和元素个数相同，也不能通过赋值运算符来复制数组的所有元素。为此，我们需要用`for`语句或`while`语句来逐个复制所有元素。
+ **交换同一类型的两个值**<br/>
想交换同一类型的两个值，可以使用下列函数宏。
```c
	#define  swap(type, x, y)  do { type t = x; x = y; y = t; } while (0)
```
+ **重新排列数组元素**<br/>
重新排列（随机重排）数组元素的方法如下（当数组类型为`int`型且元素个数为`n`时）。
```c
	for (i = n -1;i > 0;i--){
		int j = rand() % (i + 1);	/*随机数0~i*/
		if (i != j)
			swap(int, a[i], a[j]);
	}
```
+ **包含头文件保护的头文件**<br/>
为了让头文件被包含多少次都不会令程序发生故障，可以使用头文件保护的方法，像下面这样实现。
```c
	#ifndef __HEADERXX
	#define __HEADERXX
	/*声明和定义等*/
	#endif
```
&emsp;&emsp;&emsp;宏的名称`__HEADERXX`必须对应不同头文件来分别设定。
+ **库`getputch.h`**
在`scanf`函数、`getchar`函数等标准库中，在按下回车键前是无法获取键盘输入的信息的（至少在不依赖编程环境的情况下无法实现）。<br/>
因此可以使用非标准库的`getch`函数。这个函数在`MS-Windows/MS-DOS`中用`<conio.h>`声明，在提供了`Curses`库的`UNIX/Linux/OS X`中则用`<curses.h>`声明。<br/>
因为不同操作系统下的规格不同，所以建议大家利用List7-8所示的`getputch.h`来消除差异。<br/>
+ **用于接收可变参数的函数**<br/>
定义用于接收可变参数的函数时，使用`<stdarg.h>`提供的类型和库群。<br/>
`va_list`型：用于访问可变参数的类型。<br/>
`va_start`宏：负责访问可变参数前的准备工作。<br/>
`va_arg`宏：负责访问后一个可变参数。<br/>
`va_end`宏：负责结束访问可变参数。<br/>
此外，作为以`printf`函数、`fprintf`函数、`sprintf`函数为标注的库，我们还为大家介绍了`vprintf`函数、`vfprintf`函数、`vsprintf`函数。这些函数末尾的参数是`va_list`型，不是可变参数。由这些函数来进行可变参数的处理，可以很容易地在展开并整理参数后实现输出。
## chap08:打字练习
	内容：*消除已输入的字符
		  *重新排列出题顺序
		  *访问以其他数组元素的值为下标的数组元素
		  *交换指针值
		  *生成与之前生成的随机数数值不同的随机数
		  *表示键盘的字符串
		  *从选项中进行多选
小结：
+ **生成跟上一次生成的随机数不同的随机数**<br/>
为了避免连续生成值相同的随机数，我们需要循环生成跟上一次生成的随机数值不同的随机数。
```c
	zenkai = n;		/*上一次的随机数（赋给的值在生成的范围外）*/
	while (/*...*/) {	/*多次循环*/
		do {
			konkai =  rand() % n;	/*生成随机数0~n-1*/
		} while (konkai == zenkai);
		/*这次生成的随机数`konkai`和上一次生成的随机数`zenkai`值不同*/
		zenkai = konkai;
	}
```
## chap09:文件处理
	内容：*文件和流
		  *标准流
		  *缓冲区
		  *重定向
		  *文本文件
		  *二进制文件
		  FILE型
		  fclose函数
		  fflush函数
		  fgetc函数
		  fopen函数
		  fprintf函数
		  fputc函数
		  fputs函数
		  fread函数
		  fscanf函数
		  fwrite函数
		  getchar函数
		  setbuf函数
		  setvbuf函数
		  EOF
		  stderr
		  stdin
		  stdout
小结：
+ **流和标注流**<br/>
向文件和机器输入和输出字符这一操作是通过流来进行的，标准输入流`stdin`/标准输出流`stdout`/标准错误流`stderr`这3个流在程序开始运行时就准备就绪了。<br/>
多数环境中能够通过重定向来更改标准输入流和标准输出流的连接设备。
+ **文件的打开和关闭** <br/>
使用`fopen`函数打开文件并将其与流相连接，结束文件的使用并断开与流的连接时使用`fclose`函数。
+ **文件的访问**<br/>
访问文件时使用指向`fopen`函数返回的`FILE`型对象的指针，读写操作则可以通过`fprintf`函数、`fputc`函数、`fputs`函数、`fscanf`函数、`fgetc`函数等库来进行。
+ **缓冲**
不立即对流执行读写操作，而是先把字符暂时存储到缓冲区，之后再执行。缓冲方法分为全缓冲、行缓冲、无缓冲。使用`setvbuf`函数及`setbuf`函数可以设定或更改缓冲方法。<br/>
此外，使用`fflush`函数可以刷新（清空）堆积在输出流缓冲区的字符。<br/>

## chap10:英语单词学习软件
	内容：*选项形式的学习软件
		  *为字符串数组动态分配空间（二维数组/指针数组）
		  *从文件中读取单词
小结：
+ **为字符串数组动态分配空间**<br/>
为字符串数组动态分配空间，既可以以二维数组的形式进行，也可以以指向字符串的指针数组的形式进行。后者更适合处理因字符串不同而导致字符数不同的数组（但是程序会变得复杂）。
+ **大量数据的处理**<br/>
数据量达到一定规模后，可以单独准备一个文件用来读取数据，而不是直接在源程序中写入数据。